<!DOCTYPE html>
<html>
<head>
    <title>お絵かきホワイトボード</title>
    <style>
        body { margin: 0; }
        canvas { display: block; touch-action: none; } /* スクロールを防ぐ */
        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .controls button, .controls input[type="range"], .controls select, .color-picker-container {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        .controls input[type="range"] {
            width: 120px;
        }
        .color-picker-container {
            display: flex;
            align-items: center;
        }
        .color-picker-container label {
            margin-right: 5px;
        }
        #colorPicker {
            width: 40px;
            height: 40px;
            -webkit-appearance: none;
            border: none;
            cursor: pointer;
        }
        #colorPicker::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        #colorPicker::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button id="resetBtn">リセット</button>
        <button id="saveBtn">保存</button>
        <button id="loadBtn">読み込み</button>
        <button id="deleteBtn">削除</button>
        <label for="penSize">ペンの太さ:</label>
        <input type="range" id="penSize" min="1" max="20" value="5">
        <label for="eraserSize">消しゴム:</label>
        <input type="range" id="eraserSize" min="5" max="30" value="10">
        <button id="eraserBtn">消しゴム</button>
        <button id="penBtn">ペン</button>
        <div class="color-picker-container">
            <label for="colorPicker">色:</label>
            <input type="color" id="colorPicker" value="#000000">
        </div>
    </div>
    <canvas id="whiteboard"></canvas>
    <script>
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const penSizeInput = document.getElementById('penSize');
        const eraserSizeInput = document.getElementById('eraserSize');
        const eraserBtn = document.getElementById('eraserBtn');
        const penBtn = document.getElementById('penBtn');
        const colorPicker = document.getElementById('colorPicker');

        let drawing = false;
        let currentTool = 'pen';
        let savedDrawings = [];
        let selectedDrawingIndex = -1;
        let currentColor = '#000000'; // 初期の色を黒に設定

        // Canvasのサイズをウィンドウサイズに合わせる
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redrawCanvas();
        }

        // 保存された絵を再描画する
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (selectedDrawingIndex !== -1 && savedDrawings[selectedDrawingIndex]) {
                const img = new Image();
                img.onload = function() {
                    ctx.drawImage(img, 0, 0);
                };
                img.src = savedDrawings[selectedDrawingIndex];
            } else if (savedDrawings.length > 0) {
                // 最新の保存があれば表示
                const img = new Image();
                img.onload = function() {
                    ctx.drawImage(img, 0, 0);
                };
                img.src = savedDrawings[savedDrawings.length - 1];
            }
        }

        // 描画開始 (マウスとタッチの両方に対応)
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('touchstart', startDrawing);

        function startDrawing(e) {
            drawing = true;
            startX = e.clientX || e.touches[0].clientX;
            startY = e.clientY || e.touches[0].clientY;
            e.preventDefault(); // デフォルトのタッチ操作を防止
        }

        // 描画処理 (マウスとタッチの両方に対応)
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchmove', draw);

        function draw(e) {
            if (!drawing) return;
            const currentX = e.clientX || e.touches[0].clientX;
            const currentY = e.clientY || e.touches[0].clientY;

            ctx.lineWidth = currentTool === 'pen' ? penSizeInput.value : eraserSizeInput.value;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (currentTool === 'pen') {
                ctx.strokeStyle = currentColor;
                ctx.globalCompositeOperation = 'source-over';
            } else if (currentTool === 'eraser') {
                ctx.strokeStyle = getComputedStyle(canvas).backgroundColor;
                ctx.globalCompositeOperation = 'destination-out';
            }

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            startX = currentX;
            startY = currentY;
            e.preventDefault(); // デフォルトのタッチ操作を防止
        }

        // 描画終了 (マウスとタッチの両方に対応)
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        function stopDrawing() {
            drawing = false;
        }

        // リセットボタン
        resetBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            selectedDrawingIndex = -1;
        });

        // 保存ボタン
        saveBtn.addEventListener('click', () => {
            const imageData = canvas.toDataURL();
            savedDrawings.push(imageData);
            selectedDrawingIndex = savedDrawings.length - 1;
            alert('絵を保存しました！');
        });

        // 読み込みボタン
        loadBtn.addEventListener('click', () => {
            if (savedDrawings.length > 0) {
                const index = prompt(`読み込む絵の番号を入力してください (0〜${savedDrawings.length - 1})`);
                const numIndex = parseInt(index);
                if (!isNaN(numIndex) && numIndex >= 0 && numIndex < savedDrawings.length) {
                    selectedDrawingIndex = numIndex;
                    redrawCanvas();
                    alert(`${numIndex}番の絵を読み込みました。`);
                } else {
                    alert('無効な番号です。');
                }
            } else {
                alert('保存された絵はありません。');
            }
        });

        // 削除ボタン
        deleteBtn.addEventListener('click', () => {
            if (savedDrawings.length > 0) {
                const index = prompt(`削除する絵の番号を入力してください (0〜${savedDrawings.length - 1})`);
                const numIndex = parseInt(index);
                if (!isNaN(numIndex) && numIndex >= 0 && numIndex < savedDrawings.length) {
                    savedDrawings.splice(numIndex, 1);
                    selectedDrawingIndex = -1;
                    redrawCanvas();
                    alert(`${numIndex}番の絵を削除しました。`);
                } else {
                    alert('無効な番号です。');
                }
            } else {
                alert('保存された絵はありません。');
            }
        });

        // ペンボタン
        penBtn.addEventListener('click', () => {
            currentTool = 'pen';
        });

        // 消しゴムボタン
        eraserBtn.addEventListener('click', () => {
            currentTool = 'eraser';
        });

        // 色選択
        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            currentTool = 'pen'; // 色を変えたら自動的にペンツールに戻す
        });

        // ウィンドウのリサイズに対応
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // 初期化時にサイズを調整
    </script>
</body>
</html>
